import { BuildOptions, build as ESBuild } from "esbuild";
import { Endpoint, Module, VALID_EXPORTS } from "../models";
import fs from "fs";
import { Utility } from "../utilities";


const VERCEL_FUNCTION_CONFIG = {
    "runtime": "edge",
    "entrypoint": "index.js"
};
const ESBUILD_TARGET = {
    target: "es2020",
    format: "esm",
    bundle: true,
    allowOverwrite: true,
    treeShaking: true,
    minify: true,
};


export async function Bundler(module:Module, output:string) {
    for (let endpoint of module.endpoints) {
        await build(endpoint, module.config.path, output);
    }
    fs.writeFileSync(Utility.File.JoinPath(output, "config.json"), JSON.stringify(
        {
            "version": 3,
            "routes": dynamicRoutes(module.endpoints)
        }
    ));
    // return ModuleMiddleware
}


async function build(endpoint:Endpoint, configPath:string, output:string) {
    let route  = endpoint.route.map((route) => route.isDynamic ? `[${route.name}]` : route.name).join("/");
    let outdir = Utility.File.JoinPath(output, "functions", route, "/index.func");
    try {
        await buildEndpoint(endpoint, outdir);
        await buildHandler(endpoint, outdir);
        await buildConfigModule(configPath, outdir);
        await buildVercelConfig(outdir);
    } catch (e) {
        console.error(e);
    }
}


async function buildEndpoint(endpoint:Endpoint, output:string) {
    await ESBuild({
        entryPoints: [endpoint.filepath],
        outfile: Utility.File.JoinPath(output, "endpoint.js"),
        ...ESBUILD_TARGET as Partial<BuildOptions>
    });
}


async function buildConfigModule(configPath:string, output:string) {
    await ESBuild({
        entryPoints: [configPath],
        outfile: Utility.File.JoinPath(output, "config.module.js"),
        ...ESBUILD_TARGET as Partial<BuildOptions>
    });
}


async function buildVercelConfig(output:string) {
    let buffer = JSON.stringify(VERCEL_FUNCTION_CONFIG);
    fs.writeFileSync(Utility.File.JoinPath(output, ".vc-config.json"), buffer);
}


async function buildHandler(endpoint:Endpoint, output:string) {
    let buffer = getEdgeHandlerCode(endpoint);
    fs.writeFileSync(Utility.File.JoinPath(output, "index.js"), buffer);
}


function getEdgeHandlerCode(endpoint:Endpoint) {
    let varibles = endpoint.exports.filter(o => VALID_EXPORTS.includes(o));
    return [
        `// Generated by SherpaJS`,
        `import { ${varibles.join(", ")} } from "./endpoint";`,
        ``,
        `export default async function index(request, event) {`,
            `\tswitch (request.method) {`,
                `${varibles.map((v) => `\t\tcase "${v}": return ${v}(request);`).join("\n")}`,
            `\t}`,
            `\treturn new Response("Unsupported method \\"" + request.method + "\\".", { status: 405 });`,
        `}`
    ].join("\n");    
}


function dynamicRoutes(endpoints:Endpoint[]):{ src:string, dest:string }[] {
    return endpoints.filter((endpoint) => {
        return endpoint.route.filter((route) => route.isDynamic).length > 0;
    }).map((endpoint) => {
        let routes  = endpoint.route;
        let dynamic = routes.filter((route) => route.isDynamic);
        let source  = "/" + routes.map(r => r.isDynamic ? `(?<${r.name}>.*)` : r.name).join("/");
        let dest    = "/" + routes.map(r => r.isDynamic ? `[${r.name}]` : r.name).join("/");
        let query   = dynamic.map((r) => r.name + "=$" + r.name).join("&");
        return {
            src: source,
            dest: dest + "?" + query
        }
    });
}

